# Random Prompt Generator: Context Interactions Documentation

## Overview

The Random Prompt Generator is a modular system for creating dynamic, randomized prompts using namespaced components published in packages. Key elements include:

- **Datatypes**: Namespaced references to datalists containing values with optional key/value tags (e.g., `article: a`, `gender: masculine`, `mood: cheerful`). These provide raw data that can be selected randomly or based on context.
- **Promptsections**: Namespaced templates that render text, referencing datatypes, other promptsections, or context values. References can include min/max counts for repetition, concatenated via separatorsets.
- **Separatorsets**: Namespaced sets of three separators (e.g., primary: ", ", secondary: " and ", tertiary: ", and ") for handling lists of 1+ items.
- **Rulebooks**: Namespaced configurations that define entry promptsections (with weights) for generating batches of prompts.
- **Pools**: Optional namespaced collections that aggregate rendered items from datatypes or promptsections, allowing templates to draw random items from them.

The system emphasizes modularity: Authors can mix namespaces from different packages, with external namespaces resolved via dependencies. Minimal logic is hardcoded; most behaviors (including article selection or gender agreement) are defined declaratively by package authors.

Central to the system is the **rendering context**, a dynamic store (inspired by SPA stores) that enables interactions between components during rendering. This allows upstream templates to request information (e.g., an article or gender), which downstream components can fulfill based on declarative rules. This documentation focuses on the rendering context, ContextInterfaces, and related interactions, including decisions for unspecified aspects to ensure flexibility and minimal hardcoding.

## The Rendering Context

The rendering context is a namespaced, scoped key-value store that persists during the rendering of a single prompt. It acts as a shared blackboard for components to read from, write to, or react to, enabling dynamic decisions without tight coupling.

### Key Features
- **Namespacing**: All keys are prefixed with a namespace (e.g., `featured.common:article_requested`). This prevents collisions and allows packages to define their own semantics.
- **Scopes**: To handle nesting (e.g., in repeated sections), keys can include a scope suffix (e.g., `.global`, `.prompt`, `.section.<id>`). Scopes are hierarchical:
    - `.global`: Shared across all prompts in a batch (rarely used, for rulebook-level state).
    - `.prompt`: Shared within one prompt.
    - `.section.<id>`: Local to a promptsection instance, where `<id>` is a unique render-time identifier (auto-generated by the engine).
    - Custom scopes can be defined by authors (e.g., `.character.<name>` for per-entity state).
    - Fallback: Reads fall back up the hierarchy if a key is unset in the current scope (e.g., from `.section.<id>` to `.prompt` to `.global`).
- **Data Types**: Values can be strings, numbers, booleans, lists, or maps. Basic operations (e.g., append to list) are supported via template expressions.
- **Access Methods**: Templates and components interact via simple expressions:
    - `context.get(namespace:key.<scope>)`: Retrieves a value (returns null if unset).
    - `context.set(namespace:key.<scope>, value)`: Sets a value.
    - `context.has(namespace:key.<scope>)`: Checks if set.
    - `context.request(namespace:key.<scope>)`: Sets a request flag (e.g., to true) to signal a need for contribution.
    - `context.random(namespace:key.<scope>, options)`: Selects randomly from a list or range (e.g., for built-in randomness).
- **Lifecycle**: Context is initialized empty per prompt, populated during rendering, and discarded after. No persistence across prompts unless explicitly copied via rulebook config.
- **Built-in Basics**: Minimal hardcoded datatypes for core utilities, e.g.:
    - `system.random:int(min, max)`: Generates a random integer.
    - `system.random:float(min, max)`: Generates a random float.
    - `system.random:choice(list)`: Picks from a list.
      These are invoked in templates like `{system.random:int(1,10)}` and can set context values if needed.

The engine renders templates depth-first: It processes a promptsection, resolves its references (datatypes or sub-sections), and evaluates context interactions in order. This sequential rendering allows "first-come" contribution logic.

## ContextInterfaces

ContextInterfaces are first-class, namespaced definitions that declare how components interact with the context. They are defined in packages (e.g., in `featured.common`) and act as contracts: specifying keys, their semantics, and contribution rules. This keeps logic declarative and author-definable, with no hardcoding beyond basic access methods.

### Structure of a ContextInterface
Each ContextInterface is a JSON-like object (or equivalent in the package format) with:

- **Namespace**: The owning namespace (e.g., `featured.common`).
- **Keys**: A map of key names (without namespace prefix) to definitions:
    - `type`: String, number, boolean, list, map, etc.
    - `default`: Optional default value.
    - `description`: Human-readable explanation (for docs).
    - `request_key`: Optional sibling key for requests (e.g., `article_requested` for `article_choice`).
- **Contributions**: A list of rules for how components (datatypes or promptsections) can fulfill keys. Each rule:
    - `condition`: Expression to check (e.g., `context.has(request_key) && !context.has(target_key)`).
    - `action`: How to set the value (e.g., `context.set(target_key, random_from_my_tags('article'))`).
    - `priority`: Optional integer (higher = earlier evaluation; defaults to render order).
    - `applies_to`: Filter for which component types (e.g., datatypes tagged as "noun" or "adverb").
- **Validators**: Optional expressions to validate values post-set (e.g., ensure `gender` is one of ["masculine", "feminine", "neutral"]).

Example (pseudo-JSON for `featured.common:article_interface`):
```
{
  "namespace": "featured.common",
  "keys": {
    "article_requested": { "type": "boolean", "default": false, "description": "Flag if an article is needed." },
    "article_choice": { "type": "string", "description": "Chosen article (e.g., 'a', 'an', 'the').", "request_key": "article_requested" }
  },
  "contributions": [
    {
      "condition": "context.get('featured.common:article_requested.<scope>') == true && !context.has('featured.common:article_choice.<scope>')",
      "action": "context.set('featured.common:article_choice.<scope>', random_choice(my_tags['article']))",
      "priority": 10,
      "applies_to": "datatypes with tag 'article_provider'"
    }
  ],
  "validators": {
    "article_choice": "value in ['a', 'an', 'the']"
  }
}
```

### Usage
- **Declaration**: Packages include ContextInterfaces as files or entries in their manifest.
- **Referencing**: Templates reference interfaces implicitly via key usage. The engine loads relevant interfaces based on namespaces in use.
- **Extension**: Authors can extend interfaces from other namespaces (e.g., add custom keys or rules) via package dependencies.
- **Discovery**: Rulebooks can specify required interfaces; the engine validates at load time.

This design allows authors to define complex logic like article selection or gender agreement entirely in data, without engine changes.

## How Components Interact with the Context

Components (primarily datatypes and promptsections) declare their context behaviors in their definitions. During rendering:

1. **Requests**: A template can request via `context.request(namespace:key.<scope>)`, setting a flag.
2. **Rendering Order**: The engine renders references sequentially (left-to-right in templates).
3. **Contribution Evaluation**: For each rendered component:
    - If it matches a contribution's `applies_to` (via tags or type),
    - Evaluate the `condition`,
    - If true, execute the `action` (which may use component data, like tags).
4. **Reading**: Downstream templates read values via `context.get()`.
5. **Pools Integration**: Pools can be context-backed (e.g., `context.set(pool_key, append(rendered_item))`), allowing random draws like `{context.random(pool_key, 1)}`.

### Decision for Missing Parts: Contribution Triggers
To handle "first" contribution without hardcoding, contributions evaluate in render order (or priority). If multiple match, the first successful one sets the value; others skip if already set. This mimics the example where the first noun/adverb contributes.

### Handling Pools
Pools are formalized as context keys (e.g., `featured.common:pool.<name>.<scope>`), typed as lists. Templates can:
- Add: `context.set(pool_key, append({datatype_ref}))`.
- Draw: `{context.random(pool_key, count=min-max)}`.

### Error Handling
- Unset required values: Engine logs warnings but continues with defaults.
- Invalid values: Validators throw errors if defined.

## Examples

### Article Selection
Template in a promptsection: "The {context.request('featured.common:article_requested.<scope>')} {noun_datatype} is {adjective_datatype}."

- Render noun_datatype (tagged "article_provider"): Checks condition, sets `article_choice` to "a" (from its tags).
- Output: "The a cat is fluffy." (Adjective might adjust if it has its own rule.)

Authors define tags like `article: a|an` in datalists, with rules selecting based on vowel sounds (via custom conditions).

### Gender Agreement
Interface `featured.common:gender_interface` with keys `gender_requested`, `gender_choice`.
Noun datatype contributes from tags (e.g., `gender: feminine`).
Downstream verbs use `context.get('featured.common:gender_choice.<scope>')` to conjugate.

### Random Pool
Template: "{context.set('pool:characters', append({character_datatype}))} ... A story with {context.random('pool:characters', 3)}."

This collects characters upstream and draws randomly downstream.

## Best Practices
- Use narrow scopes to avoid pollution.
- Define interfaces in `featured.common` for shared building blocks (e.g., articles, moods).
- Test contributions in isolation via debug mode.
- Avoid cycles: Engine detects and errors on recursive requests.

This system ensures flexibility: All logic, including articles, is author-defined via interfaces and tags. Extend by adding packages with new namespaces/interfaces.